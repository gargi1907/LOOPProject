# COMPILED VS INTERPRETED LANGUAGES ANALYSIS



## Compiled Languages

Compiled languages are converted directly into machine code that the processor can execute. As a result, they tend to be faster and more efficient to execute than interpreted languages. They also give the developer more control over hardware aspects, like memory management and CPU usage.

Compiled languages need a “build” step - they need to be manually compiled first. You need to “rebuild” the program every time you need to make a change.

Examples of pure compiled languages are C, C++, Erlang, Haskell, Rust, and Go.

##  Interpreted Languages

Interpreters will run through a program line by line and execute each command.

Interpreted languages were once known to be significantly slower than compiled languages. But, with the development of just-in-time compilation, that gap is shrinking.

Examples of common interpreted languages are Java, PHP, Ruby, Python, and JavaScript.

##  Advantages and Disadvantages

### Advantages of Compiled Languages

Programs compiled into native code at compile time usually tend to be faster than those translated at run time, due to the overhead of the translation process.

### Disadvantages of Compiled Languages
The most notable disadvantages are :-
-   Additional time needed to complete the entire compilation step before testing, and
-   Platform dependence of the generated binary code.

### Advantages of Interpreted Languages

An Interpreted language gives implementations some additional flexibility over compiled implementations. Because interpreters execute the source program code themselves, the code itself is platform independent (Java’s byte code, for example). Other features include dynamic typing, and smaller executable program size.
### Disadvantages of Interpreted Languages
 The most notable disadvantage is less execution speed compared to compiled languages


# Comparative Analysis of Different Languages ( C , C++,Python)

## C vs C ++

The _C++ vs C Comparison Ratio_ columns, with performance degradation ratios as high as 2.667, clearly depict the unacceptable performance of C++ versus C. This is because

C++ allows you to write abstractions that compile-down to equivalent C. This means that with some care, a C++ program will be at least as fast as a C one. The advantage C++ gives over C is that it enables us to also build reusable abstractions with templates, OOP and functional composition.

C++ gives you the tools to encode your intentions in the type-system. This allows the compiler to generate optimal binaries from your code.

## Python vs C ++

The _Python vs C++_ columns show performance degradation ratios as high as 404(avg).

When it comes to Python vs C++, it is a dynamic language which reduces complexity when it comes to collaborating and optimizes programmer efficiency.  C++ has the advantage of being a statically typed language. The performance crown goes to C++ for creating a more compact and faster runtime code.

## C vs Python

**Python is 662(avg) times slower than C because it is an interpreted language.**  python code will be interpreted, instead of directly by the CPU.

_This makes all the difference in the world, regarding performance._

Python code almost always runs in a virtual machine.

Another name for a virtual machine is a “bytecode interpreter”.

_Interpreted code is always slower than direct machine code, because it takes a lot more instructions in order to implement an interpreted instruction than to implement an actual machine instruction._
## Manage file synchronization

Since one file can be synced with multiple locations, you can list and manage synchronized locations by clicking **File synchronization** in the **Synchronize** sub-menu. This allows you to list and remove synchronized locations that are linked to your file.


# Comparative Analysis of Different Processors ( i3,i5,i7)


Intel’s current core processors are divided into three ranges(Core i3, Core i5 and Core i7), with several models in each range.

| **PERSONAL COMPUTER**| Clock Speed Range(Several Models) |
|--|--|
|**INTEL CORE I3**  | 3.4GHz – 4.2GHz |
|**INTEL CORE I5** | 2.4GHz – 3.8GHz |
|**INTEL CORE I7** | 2.9GHz – 4.2GHz
 |
















The clock speed (or clock rate) is stated in megahertz (MHz) or gigahertz (GHz) and refers to the speed at which the processor can execute instructions. The faster the clock, the more instructions the processor can complete per second.

_All else being equal,_ processors with faster clock speeds process data faster than those with slower clock speeds.

This may be interesting, **the slowest Core i3 chips runs at a faster speed than the base Core i5 and Core i7.**

Core i3 processors don’t have Turbo Boost, but Core i5 and Core i7s do. Turbo Boost dynamically increases the clock speed of Core i5 and i7 processors when more power is required. This means that the chip can draw less power, produce less heat and only boost when it needs to. For example, although a Core i3-7300 runs at 4GHz compared to 3.5GHz for the Core i5-7600, the Core i5 chip can boost up to 4.1GHz when required, so will end up being quicker. A processor can only Turbo Boost for a limited amount of time. It is a significant part of the reason why Core i5 and Core i7 processors outperform Core i3 models in single-core-optimized tasks, even though they have lower base clock speeds.

That’s why, i7 processor takes the least time to execute the program while i3 processor takes more time to execute than i5 as it does not have a Turbo Boost like i5 and i7.
